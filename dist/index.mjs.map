{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["import socketIO from 'socket.io-client';\nimport nanobus from 'nanobus';\n\n/**\n * The error types that cause the {@link SocketEvents} 'error' event to fire.\n * @type {Object} SOCKET_ERROR\n * @property {string} GENERAL A general socket error.\n * @property {string} TIMEOUT The ping to the server timed out.\n * @property {string} NO_ATTEMPTS_LEFT The client ran out of attempts to reconnect to the server.\n * @property {string} AUTH_FAILED The client is not granted access to the server.\n * @since 1.0.0\n */\nexport const SOCKET_ERROR = {\n\tGENERAL: 'GENERAL',\n\tTIMEOUT: 'TIMEOUT',\n\tNO_ATTEMPTS_LEFT: 'NO_ATTEMPTS_LEFT'\n};\n\n/**\n * The disconnect reason that gets passed along with the {@link SocketEvents} 'disconnect' event.\n * @type {Object} DISCONNECT_REASON\n * @property {string} UNKNOWN An unknown disconnect reason.\n * @property {string} SERVER_DISCONNECT The server disconnected the client. A manual reconnect would be required.\n * @property {string} CLIENT_DISCONNECT The client disconnected from the server. A manual reconnect would be required.\n * @property {string} PING_TIMEOUT The ping to the server timed-out. The client will automatically try to reconnect.\n * @since 1.0.0\n */\nexport const DISCONNECT_REASON = {\n\tUNKNOWN: 'UNKNOWN',\n\tSERVER_DISCONNECT: 'SERVER_DISCONNECT',\n\tCLIENT_DISCONNECT: 'CLIENT_DISCONNECT',\n\tPING_TIMEOUT: 'PING_TIMEOUT'\n};\n\n/**\n * As ESDoc lacks a way to properly document events, this typedef shows all the different events the client might emit.\n * The \"type\" below is the callback argument for the listener.\n * @typedef SocketEvents\n * @property {void} connect Emitted on a successful connect to the server.\n * @property {DISCONNECT_REASON} disconnect Emitted when the client disconnected from the server. The disconnect reason indicates why.\n * @property {SOCKET_ERROR, object} error Emitted when the encounters an error. The first argument is the {@link SOCKET_ERROR} object, indicating what the error object might be.\n * @property {Number} reconnecting Emitted once the clients starts trying to reconnect to the server. Attempt number passed to the listener.\n *\n * @example\n * client.on('error', (errorType, errorData) => {});\n * client.on('disconnect', reason => {});\n * client.on('reconnecting', attempt => {});\n */\n\n/**\n * The mission control client class.\n *\n * You can easily build your own client implementation, this one is just easy to use and has everything you might need.\n * @since 1.0.0\n * @emits {connect} emit event when bar.\n */\nexport class MissionControlClient {\n\t/**\n\t * The MissionControlClient constructor.\n\t *\n\t * You can easily build your own client implementation, this one is just easy to use and has everything you might need.\n\t * @param {string} url - The mission control url the client should connect to.\n\t * @param {string} authToken - The JWT authentication token that should be used to authenticate.\n\t */\n\tconstructor(url, authToken) {\n\t\t// URL and auth token are required parameters.\n\t\tif (!url) throw new Error('You need to pass an URL.');\n\t\tif (!authToken) throw new Error('You need to pass an Auth Token.');\n\n\t\t/**\n\t\t * The socket.io socket used for the communication.\n\t\t *\n\t\t * While it is possible it is recommended not to use this variable directly and to use the exposed {@link MissionControlClient#action} and {@link MissionControlClient#subscribe} methods instead.\n\t\t *\n\t\t * @type socket.io-client~Socket\n\t\t * @since 1.0.0\n\t\t */\n\t\tthis.socket = socketIO(url, {\n\t\t\tquery: { token: authToken }\n\t\t});\n\n\t\t/**\n\t\t * The event bus used to communicate events within the client.\n\t\t *\n\t\t * While it is possible it is recommended not to use this variable directly and to use the exposed {@link MissionControlClient#on} and {@link MissionControlClient#subscribe} methods instead.\n\t\t *\n\t\t * @type socket.io-client~Nanobus\n\t\t * @emits {SocketEvent}\n\t\t * @since 1.0.0\n\t\t */\n\t\tthis.eventBus = nanobus();\n\n\t\t/** @type {Object<eventKey<string>, listenerCount<Number>>} */\n\t\tthis._subscriptions = {};\n\t\t/** @type {Array<eventKey<string>>} */\n\t\tthis._subscribeTo = [];\n\t\t/** @type {Array<eventKey<string>>} */\n\t\tthis._unsubscribeFrom = [];\n\n\t\tthis._setupSocketHandlers();\n\t}\n\n\t/**\n\t * This function sets up all the listeners for the socket (connect, disconnect, error, reconnect, etc).\n\t *\n\t * Job of this function is to unify all error events into a shape that makes more sense. See {@link SOCKET_ERROR} for the possible errors.\n\t */\n\t_setupSocketHandlers() {\n\t\t// We hijack the on event method to call it again with the '*' event which now gets called on\n\t\t// any event.\n\t\tconst socketOnEvent = this.socket.onevent;\n\t\tthis.socket.onevent = function(packet) {\n\t\t\tconst args = packet.data || [];\n\t\t\tsocketOnEvent.call(this, packet);\n\n\t\t\tpacket.data = ['*'].concat(args);\n\t\t\tsocketOnEvent.call(this, packet); // additional call for \"*\" event\n\t\t};\n\n\t\t// This catches all other events and published them to our event bus\n\t\tthis.socket.on('*', (event, ...args) => {\n\t\t\tthis.eventBus.emit(event, ...args);\n\t\t});\n\n\t\t// On successful connection\n\t\tthis.socket.on('connect', () => {\n\t\t\t// While we still have events to subscribe to, do so on connect\n\t\t\twhile (this._subscribeTo.length > 0) {\n\t\t\t\tthis.socket.emit('subscribe', {\n\t\t\t\t\tevent: this._subscribeTo.shift()\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// While we still have events to unsubscribe from, do so on connect\n\t\t\twhile (this._unsubscribeFrom.length > 0) {\n\t\t\t\tthis.socket.emit('unsubscribe', {\n\t\t\t\t\tevent: this._unsubscribeFrom.shift()\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.eventBus.emit('connect');\n\t\t});\n\n\t\t// On disconnect from server, reason can either be server disconnect, client disconnect or ping timeout.\n\t\tthis.socket.on('disconnect', reason => {\n\t\t\tlet disconnectReason;\n\n\t\t\tswitch (reason) {\n\t\t\t\tcase 'io server disconnect':\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.SERVER_DISCONNECT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'io client disconnect':\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.CLIENT_DISCONNECT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ping timeout':\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.CLIENT_DISCONNECT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.UNKNOWN;\n\t\t\t}\n\n\t\t\tthis.eventBus.emit('disconnect', disconnectReason);\n\t\t});\n\n\t\t/*\n\t\t * RECONNECTION\n\t\t */\n\t\t// On successful reconnect, attempt is the amount of attempts needed for the reconnect.\n\t\t// As of right now, not really needed for anything,\n\t\t// as the connect event fires on every successful connect, even reconnects.\n\t\t// this.socket.on('reconnect', attempt => {});\n\n\t\t// On reconnect attempt, attempt is the current attempt number\n\t\tthis.socket.on('reconnect_attempt', attempt => {\n\t\t\tthis.eventBus.emit('reconnecting', attempt);\n\t\t});\n\n\t\t/*\n\t\t * ERROR HANDLING\n\t\t */\n\t\t// On a general connection error, the error object is the error thrown\n\t\tthis.socket.on('connect_error', error => {\n\t\t\t// TODO: determine errorType\n\t\t\tthis.eventBus.emit('error', SOCKET_ERROR.GENERAL, error);\n\t\t});\n\n\t\t// On a ping/connection timeout error, the timeout object is IDK what\n\t\t// TODO: what is the timeout object?\n\t\tthis.socket.on('connect_timeout', timeout => {\n\t\t\tthis.eventBus.emit('error', SOCKET_ERROR.TIMEOUT, timeout);\n\t\t});\n\n\t\t// On reconnect error, dont know if needed for now\n\t\t// this.socket.on('reconnect_error', error => {});\n\n\t\t// On reconnection failed, fired becayse we run out of attempts\n\t\t// and not because there is an error in the connection\n\t\tthis.socket.on('reconnect_failed', () => {\n\t\t\tthis.eventBus.emit('error', SOCKET_ERROR.NO_ATTEMPTS_LEFT);\n\t\t});\n\t}\n\n\t/**\n\t * Listen to a socket event.\n\t *\n\t * Please note, if you want to subscribe to action or state events, please use the {@link subscribe} method.\n\t * The returned function can be used to unsubscribe from the event listener again.\n\t * This makes it possible to for example remove inline listeners.\n\t *\n\t * @param {string} event - The socket event you want to listen to.\n\t * @param {function(data: object)} listener - The listener function that will be called on event.\n\t * @return {function} Returns a function which you can use to remove the event listener.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * on('connect', () => {})\n\t * on('error', (errorType, errorObject) => {})\n\t */\n\ton(event, listener) {\n\t\tthis.eventBus.on(event, listener);\n\n\t\treturn () => this.eventBus.removeListener(event, listener);\n\t}\n\n\t/**\n\t * Listen to a socket event, and clear it after it's been called once.\n\t *\n\t * Please note, if you want to subscribe to action or state events, please use the {@link subscribe} method.\n\t * The returned function can be used to unsubscribe from the event listener again.\n\t * This makes it possible to for example remove inline listeners.\n\t *\n\t * @param {string} event - The socket event you want to listen to.\n\t * @param {function(data: object)} listener - The listener function that will be called on event once.\n\t * @return {function} Returns a function which you can use to remove the event listener.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * once('connect', (data) => {})\n\t */\n\tonce(event, listener) {\n\t\tthis.eventBus.once(event, listener);\n\n\t\treturn () => this.eventBus.removeListener(event, listener);\n\t}\n\n\t/**\n\t * Subscribe to a server event (actions, state updates).\n\t *\n\t * To subscribe to a server event, we need to emit a 'subscribe' event to the server so it knows\n\t * to broadcast the right events to us. This function automatically handles these 'subscribe' and\n\t * 'unsubscribe' events so you can simply use this method to do it. When we disconnect from\n\t * the server, this function also handles resubscribing to the events.\n\t * It returns a function that can you can use to remove the event listener again and unsubscribe from the server.\n\t *\n\t * @param {string} serverEvent - This is the server event you want to subscribe to. Keep in mind these are not general socket events, but rather state / action Mission Control events.\n\t * @param {function(data: object)} listener - The listener function that will be called on event.\n\t * @return {function} Returns a function which you can use to remove the event listener.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * client.subscribe('action:EXAMPLE:DO', (data) => {})\n\t * client.subscribe('update:stateObject', (data) => {});\n\t */\n\tsubscribe(serverEvent, listener) {\n\t\tthis.socket.on(serverEvent, listener);\n\n\t\tif (!(serverEvent in this._subscriptions)) {\n\t\t\tif (this.socket.connected) {\n\t\t\t\tthis.socket.emit('subscribe', {\n\t\t\t\t\tevent: serverEvent\n\t\t\t\t});\n\t\t\t\tthis._subscriptions[serverEvent] = 1;\n\t\t\t} else {\n\t\t\t\tthis._subscribeTo.push(serverEvent);\n\t\t\t}\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.socket.removeListener(serverEvent, listener);\n\n\t\t\tif (this.socket.connected) {\n\t\t\t\tthis._subscriptions[serverEvent]--;\n\n\t\t\t\tif (this._subscriptions[serverEvent] === 0) {\n\t\t\t\t\tdelete this._subscriptions[serverEvent];\n\n\t\t\t\t\tthis.socket.emit('unsubscribe', {\n\t\t\t\t\t\tevent: serverEvent\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._unsubscribeFrom.push(serverEvent);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Execute an action on the mission control server.\n\t *\n\t * This method sends an 'action' event, which the server will use to execute the action and modify\n\t * the state accordingly.\n\t *\n\t * @param {string} action - The action that you want to execute.\n\t * @param {object} data - The data you want to pass to the action function.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * client.action('EXAMPLE:DO', { parameter: 'example' })\n\t * client.action('VIDEO-QUEUE:PUSH', { video: { url: '...', format: 'mp4' }})\n\t */\n\taction(action, data) {\n\t\tthis.socket.emit('action', { action, data });\n\t}\n}\n"],"names":["SOCKET_ERROR","GENERAL","TIMEOUT","NO_ATTEMPTS_LEFT","DISCONNECT_REASON","UNKNOWN","SERVER_DISCONNECT","CLIENT_DISCONNECT","PING_TIMEOUT","MissionControlClient","constructor","url","authToken","Error","socket","socketIO","query","eventBus","nanobus","_subscriptions","_subscribeTo","_unsubscribeFrom","_setupSocketHandlers","socketOnEvent","onevent","packet","args","data","call","concat","on","event","emit","this","length","shift","reason","disconnectReason","attempt","error","timeout","listener","removeListener","once","subscribe","serverEvent","connected","push","action"],"mappings":"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"}