{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["import socketIO from 'socket.io-client';\nimport nanobus from 'nanobus';\n\n/**\n * The error types that cause the {@link SocketEvents} 'error' event to fire.\n * @type {Object} SOCKET_ERROR\n * @property {string} GENERAL A general socket error.\n * @property {string} TIMEOUT The ping to the server timed out.\n * @property {string} NO_ATTEMPTS_LEFT The client ran out of attempts to reconnect to the server.\n * @property {string} AUTH_INVALID_TOKEN The client is not granted access to the server due to the token being invalid.\n * @property {string} AUTH_TIMEOUT The client is not granted access to the server because the client took too long to authenticate.\n * @since 1.0.0\n */\nexport const SOCKET_ERROR = {\n\tGENERAL: 'GENERAL',\n\tTIMEOUT: 'TIMEOUT',\n\tNO_ATTEMPTS_LEFT: 'NO_ATTEMPTS_LEFT',\n\tAUTH_INVALID_TOKEN: 'AUTH_INVALID_TOKEN',\n\tAUTH_TIMEOUT: 'AUTH_TIMEOUT'\n};\n\n/**\n * The disconnect reason that gets passed along with the {@link SocketEvents} 'disconnect' event.\n * @type {Object} DISCONNECT_REASON\n * @property {string} UNKNOWN An unknown disconnect reason.\n * @property {string} SERVER_DISCONNECT The server disconnected the client. A manual reconnect would be required.\n * @property {string} CLIENT_DISCONNECT The client disconnected from the server. A manual reconnect would be required.\n * @property {string} PING_TIMEOUT The ping to the server timed-out. The client will automatically try to reconnect.\n * @since 1.0.0\n */\nexport const DISCONNECT_REASON = {\n\tUNKNOWN: 'UNKNOWN',\n\tSERVER_DISCONNECT: 'SERVER_DISCONNECT',\n\tCLIENT_DISCONNECT: 'CLIENT_DISCONNECT',\n\tPING_TIMEOUT: 'PING_TIMEOUT'\n};\n\n/**\n * As ESDoc lacks a way to properly document events, this typedef shows all the different events the client might emit.\n * The \"type\" below is the callback argument for the listener.\n * @typedef SocketEvents\n * @property {void} connect Emitted on a successful connect to the server. Called after authentication.\n * @property {DISCONNECT_REASON} disconnect Emitted when the client disconnected from the server. The disconnect reason indicates why.\n * @property {SOCKET_ERROR, object} error Emitted when the encounters an error. The first argument is the {@link SOCKET_ERROR} object, indicating what the error object might be.\n * @property {Number} reconnecting Emitted once the clients starts trying to reconnect to the server. Attempt number passed to the listener.\n *\n * @example\n * client.on('error', (errorType, errorData) => {});\n * client.on('disconnect', reason => {});\n * client.on('reconnecting', attempt => {});\n */\n\n/**\n * The mission control client class.\n *\n * You can easily build your own client implementation, this one is just easy to use and has everything you might need.\n *\n * The client hides the authentication implementation details from the user, by hijacking the `connect` event.\n * The connect event only gets called after the authentication scheme is successful.\n *\n * @since 1.0.0\n * @emits {connect} emit event when bar.\n */\nexport class MissionControlClient {\n\t/**\n\t * The MissionControlClient constructor.\n\t *\n\t * @param {string} url - The mission control url the client should connect to.\n\t * @param {string} authToken - The JWT authentication token that should be used to authenticate.\n\t */\n\tconstructor(url, authToken) {\n\t\t// URL and auth token are required parameters.\n\t\tif (!url) throw new Error('You need to pass an URL.');\n\t\tif (!authToken) throw new Error('You need to pass an Auth Token.');\n\n\t\t/**\n\t\t * The JWT authentication token that is used to authenticate.\n\t\t * @type {string}\n\t\t */\n\t\tthis.authToken = authToken;\n\n\t\t/**\n\t\t * The socket.io socket used for the communication.\n\t\t *\n\t\t * While it is possible it is recommended not to use this variable directly and to use the exposed {@link MissionControlClient#action} and {@link MissionControlClient#subscribe} methods instead.\n\t\t *\n\t\t * @type socket.io-client~Socket\n\t\t * @since 1.0.0\n\t\t */\n\t\tthis.socket = socketIO(url);\n\n\t\t/**\n\t\t * The event bus used to communicate events within the client.\n\t\t *\n\t\t * While it is possible it is recommended not to use this variable directly and to use the exposed {@link MissionControlClient#on} and {@link MissionControlClient#subscribe} methods instead.\n\t\t *\n\t\t * @type socket.io-client~Nanobus\n\t\t * @emits {SocketEvent}\n\t\t * @since 1.0.0\n\t\t */\n\t\tthis.eventBus = nanobus();\n\n\t\t/** @type {Object<eventKey<string>, listenerCount<Number>>} */\n\t\tthis._subscriptions = {};\n\t\t/** @type {Array<eventKey<string>>} */\n\t\tthis._subscribeTo = [];\n\t\t/** @type {Array<eventKey<string>>} */\n\t\tthis._unsubscribeFrom = [];\n\n\t\tthis._setupSocketHandlers();\n\t}\n\n\t/**\n\t * This function sets up all the listeners for the socket (connect, disconnect, error, reconnect, etc).\n\t *\n\t * Job of this function is to unify all error events into a shape that makes more sense. See {@link SOCKET_ERROR} for the possible errors.\n\t */\n\t_setupSocketHandlers() {\n\t\t// We hijack the on event method to call it again with the '*' event which now gets called on\n\t\t// any event.\n\t\tconst socketOnEvent = this.socket.onevent;\n\t\tthis.socket.onevent = function(packet) {\n\t\t\tconst args = packet.data || [];\n\t\t\tsocketOnEvent.call(this, packet);\n\n\t\t\tpacket.data = ['*'].concat(args);\n\t\t\tsocketOnEvent.call(this, packet); // additional call for \"*\" event\n\t\t};\n\n\t\t// This catches all other events and published them to our event bus\n\t\tthis.socket.on('*', (event, ...args) => {\n\t\t\t// Here we only pass the event to our event bus if the events arent our\n\t\t\t// own SocketEvents. If we wouldnt do this it would cause a collision\n\t\t\t// where listeners would fire twice: once for the actual socket emit and once\n\t\t\t// for our event bus. This bypasses this.\n\t\t\tif (\n\t\t\t\t!['connect', 'disconnect', 'reconnecting', 'error'].includes(\n\t\t\t\t\tevent\n\t\t\t\t)\n\t\t\t)\n\t\t\t\tthis.eventBus.emit(event, ...args);\n\t\t});\n\n\t\t// On connection we try to authenticate\n\t\tthis.socket.on('connect', () => {\n\t\t\tthis.socket.emit('authenticate', {\n\t\t\t\ttoken: this.authToken\n\t\t\t});\n\t\t});\n\n\t\t// On successful connection & authentication\n\t\tthis.socket.on('authenticated', () => {\n\t\t\t// While we still have events to subscribe to, do so on connect\n\t\t\twhile (this._subscribeTo.length > 0) {\n\t\t\t\tthis.socket.emit('subscribe', {\n\t\t\t\t\tevent: this._subscribeTo.shift()\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// While we still have events to unsubscribe from, do so on connect\n\t\t\twhile (this._unsubscribeFrom.length > 0) {\n\t\t\t\tthis.socket.emit('unsubscribe', {\n\t\t\t\t\tevent: this._unsubscribeFrom.shift()\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// We simplify the event structure here, by emitting a 'connect' event rather than a 'authenticated' event.\n\t\t\t// This essentially hides the implementation details of the authentication flow from the client user\n\t\t\t// which is what we're aiming for by making the client simple.\n\t\t\tthis.eventBus.emit('connect');\n\t\t});\n\n\t\t// On disconnect from server, reason can either be server disconnect, client disconnect or ping timeout.\n\t\tthis.socket.on('disconnect', reason => {\n\t\t\tlet disconnectReason;\n\n\t\t\tswitch (reason) {\n\t\t\t\tcase 'io server disconnect':\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.SERVER_DISCONNECT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'io client disconnect':\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.CLIENT_DISCONNECT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ping timeout':\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.CLIENT_DISCONNECT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdisconnectReason = DISCONNECT_REASON.UNKNOWN;\n\t\t\t}\n\n\t\t\tthis.eventBus.emit('disconnect', disconnectReason);\n\t\t});\n\n\t\t/*\n\t\t * RECONNECTION\n\t\t */\n\t\t// On successful reconnect, attempt is the amount of attempts needed for the reconnect.\n\t\t// As of right now, not really needed for anything,\n\t\t// as the connect event fires on every successful connect, even reconnects.\n\t\t// this.socket.on('reconnect', attempt => {});\n\n\t\t// On reconnect attempt, attempt is the current attempt number\n\t\tthis.socket.on('reconnect_attempt', attempt => {\n\t\t\tthis.eventBus.emit('reconnecting', attempt);\n\t\t});\n\n\t\t/*\n\t\t * ERROR HANDLING\n\t\t */\n\t\t// On a general connection error, the error object is the error thrown\n\t\tthis.socket.on('connect_error', error => {\n\t\t\t// TODO: determine errorType\n\t\t\tthis.eventBus.emit('error', SOCKET_ERROR.GENERAL, error);\n\t\t});\n\n\t\t// On a ping/connection timeout error, the timeout object is IDK what\n\t\t// TODO: what is the timeout object?\n\t\tthis.socket.on('connect_timeout', timeout => {\n\t\t\tthis.eventBus.emit('error', SOCKET_ERROR.TIMEOUT, timeout);\n\t\t});\n\n\t\t// Called when we can't authenticate because of an invalid auth token or because\n\t\t// the client took too long to authenticate.\n\t\tthis.socket.on('unauthorized', error => {\n\t\t\tconst authErrorType =\n\t\t\t\terror.type === 'TIMEOUT'\n\t\t\t\t\t? SOCKET_ERROR.AUTH_TIMEOUT\n\t\t\t\t\t: SOCKET_ERROR.AUTH_INVALID_TOKEN;\n\n\t\t\tthis.eventBus.emit('error', authErrorType, error);\n\t\t});\n\n\t\t// On reconnect error, dont know if needed for now\n\t\t// this.socket.on('reconnect_error', error => {});\n\n\t\t// On reconnection failed, fired becayse we run out of attempts\n\t\t// and not because there is an error in the connection\n\t\tthis.socket.on('reconnect_failed', () => {\n\t\t\tthis.eventBus.emit('error', SOCKET_ERROR.NO_ATTEMPTS_LEFT);\n\t\t});\n\t}\n\n\t/**\n\t * Listen to a socket event.\n\t *\n\t * Please note, if you want to subscribe to action or state events, please use the {@link subscribe} method.\n\t * The returned function can be used to unsubscribe from the event listener again.\n\t * This makes it possible to for example remove inline listeners.\n\t *\n\t * @param {string} event - The socket event you want to listen to.\n\t * @param {function(data: object)} listener - The listener function that will be called on event.\n\t * @return {function} Returns a function which you can use to remove the event listener.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * on('connect', () => {})\n\t * on('error', (errorType, errorObject) => {})\n\t */\n\ton(event, listener) {\n\t\tthis.eventBus.on(event, listener);\n\n\t\treturn () => this.eventBus.removeListener(event, listener);\n\t}\n\n\t/**\n\t * Listen to a socket event, and clear it after it's been called once.\n\t *\n\t * Please note, if you want to subscribe to action or state events, please use the {@link subscribe} method.\n\t * The returned function can be used to unsubscribe from the event listener again.\n\t * This makes it possible to for example remove inline listeners.\n\t *\n\t * @param {string} event - The socket event you want to listen to.\n\t * @param {function(data: object)} listener - The listener function that will be called on event once.\n\t * @return {function} Returns a function which you can use to remove the event listener.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * once('connect', (data) => {})\n\t */\n\tonce(event, listener) {\n\t\tthis.eventBus.once(event, listener);\n\n\t\treturn () => this.eventBus.removeListener(event, listener);\n\t}\n\n\t/**\n\t * Subscribe to a server event (actions, state updates).\n\t *\n\t * To subscribe to a server event, we need to emit a 'subscribe' event to the server so it knows\n\t * to broadcast the right events to us. This function automatically handles these 'subscribe' and\n\t * 'unsubscribe' events so you can simply use this method to do it. When we disconnect from\n\t * the server, this function also handles resubscribing to the events.\n\t * It returns a function that can you can use to remove the event listener again and unsubscribe from the server.\n\t *\n\t * @param {string} serverEvent - This is the server event you want to subscribe to. Keep in mind these are not general socket events, but rather state / action Mission Control events.\n\t * @param {function(data: object)} listener - The listener function that will be called on event.\n\t * @return {function} Returns a function which you can use to remove the event listener.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * client.subscribe('action:EXAMPLE:DO', (data) => {})\n\t * client.subscribe('update:stateObject', (data) => {});\n\t */\n\tsubscribe(serverEvent, listener) {\n\t\tthis.socket.on(serverEvent, listener);\n\n\t\tif (!(serverEvent in this._subscriptions)) {\n\t\t\tif (this.socket.connected) {\n\t\t\t\tthis.socket.emit('subscribe', {\n\t\t\t\t\tevent: serverEvent\n\t\t\t\t});\n\t\t\t\tthis._subscriptions[serverEvent] = 1;\n\t\t\t} else {\n\t\t\t\tthis._subscribeTo.push(serverEvent);\n\t\t\t}\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.socket.removeListener(serverEvent, listener);\n\n\t\t\tif (this.socket.connected) {\n\t\t\t\tthis._subscriptions[serverEvent]--;\n\n\t\t\t\tif (this._subscriptions[serverEvent] === 0) {\n\t\t\t\t\tdelete this._subscriptions[serverEvent];\n\n\t\t\t\t\tthis.socket.emit('unsubscribe', {\n\t\t\t\t\t\tevent: serverEvent\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._unsubscribeFrom.push(serverEvent);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Execute an action on the mission control server.\n\t *\n\t * This method sends an 'action' event, which the server will use to execute the action and modify\n\t * the state accordingly.\n\t *\n\t * @param {string} action - The action that you want to execute.\n\t * @param {object} data - The data you want to pass to the action function.\n\t *\n\t * @since 1.0.0\n\t * @example\n\t * client.action('EXAMPLE:DO', { parameter: 'example' })\n\t * client.action('VIDEO-QUEUE:PUSH', { video: { url: '...', format: 'mp4' }})\n\t */\n\taction(action, data) {\n\t\tthis.socket.emit('action', { action, data });\n\t}\n}\n"],"names":["SOCKET_ERROR","GENERAL","TIMEOUT","NO_ATTEMPTS_LEFT","AUTH_INVALID_TOKEN","AUTH_TIMEOUT","DISCONNECT_REASON","UNKNOWN","SERVER_DISCONNECT","CLIENT_DISCONNECT","PING_TIMEOUT","MissionControlClient","constructor","url","authToken","Error","socket","socketIO","eventBus","nanobus","_subscriptions","_subscribeTo","_unsubscribeFrom","_setupSocketHandlers","socketOnEvent","onevent","packet","args","data","call","concat","on","event","includes","this","emit","token","length","shift","reason","disconnectReason","attempt","error","timeout","authErrorType","type","listener","removeListener","once","subscribe","serverEvent","connected","push","action"],"mappings":"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"}